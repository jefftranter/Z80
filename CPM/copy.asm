; File copy program. Also includes useful CP/M utility functions. From
; the book "CP/M Assembly Language Programming" by Ken Barbier.
; Will build using the CP/M asm assembler if you change quoted strings
; in DB directives from double quotes to single quotes.

; MULTI-WRITE FILE COPY PROGRAM  12 SEPT 82

; ASCII CHARACTERS
CR	EQU	0DH		; CARRIAGE RETURN
LF	EQU	0AH		; LINE FEED
CTRLZ	EQU	1AH		; OPERATOR INTERRUPT

; CP/M BDOS FUNCTIONS
RCONF	EQU	1		; READ CON: INTO (A)
WCONF	EQU	2		; WRITE (A) TO CON:
RBUFF	EQU	10		; READ A CONSOLE LINE

; CP/M DISK ACCESS FUNCTIONS
INITF	EQU	13		; INITIALIZE BDOS FUNCTION
OPENF	EQU	15		; OPEN FILE FUNCTION
CLOSF	EQU	16		; CLOSE FILE FUNCTION
FINDF	EQU	17		; FIND FILE FUNCTION
DELEF	EQU	19		; DELETE A FILE FUNCTION
READF	EQU	20		; READ ONE RECORD FUNCTION
WRITF	EQU	21		; WRITE ONE RECORD FUNCTION
MAKEF	EQU	22		; CREATE FILE FUNCTION
SDMAF	EQU	26		; SET DMA FUNCTION

; CP/M ADDRESSES
RBOOT	EQU	0		; RE-BOOT CP/M SYSTEM
DRIVE	EQU	4		; CURRENT DRIVE SELECTION
BDOS	EQU	5		; SYSTEM CALL ENTRY
MEMAX	EQU	7		; MSB ON TOP OF MEMORY
TFCB	EQU	5CH		; TRANSIENT FILE CONTROL BLOCK
FCBTY	EQU	TFCB+9		; FILE TYPE IN FCB
FCBEX	EQU	TFCB+12		; FILE EXTENT IN FCB
FCBS2	EQU	TFCB+14		; SYSTEM USE IN FCB
FCBRC	EQU	TFCB+15		; RECORD COUNT IN FCB
FCBCR	EQU	TFCB+32		; CURRENT RECORD IN FCB
TBUFF	EQU	80H		; TRANSIENT BUFFER
TPA	EQU	100H		; TRANSIENT PROGRAM AREA

; CP/M FLAGS
BDAOK	EQU	0		; BDOS RETURN FOR ALL OK
BDER1	EQU	1		; BDOS RETURN ONE
BDER2	EQU	2		; BDOS RETURN TWO
BDERR	EQU	255		; BDOS RETURN ERROR FLAG

	ORG	TPA		; ASSEMBLE PROGRAM FOR TPA

START:	LXI	SP,STAK		; SET UP USER'S STACK
	LDA	DRIVE		; SAVE INITIAL DRIVE SELECTED
	STA	DRSAV
START1: CALL	CCRLF		; START A NEW LINE
	LXI	H,SINON		; WITH A SIGN-ON MESSAGE
	CALL	COMSG
	CALL	GET		; GET THE NAMED FILE
START2: CALL	CCRLF		; BEGIN WRITE PORTION
START3: CALL	SPMSG		; GET DRIVE FOR WRITE
	DB	"SELECT DRIVE FOR OUTPUT: ",0
	CALL	DRSEL		; GET A VALID DRIVE SELECT
	JZ	START3		; IF NO GOOD, TRY AGAIN
	STA	TFCB		; SET DESIGNATOR INTO FCB
	CALL	CCRLF		; AND ECHO ACCEPTANCE
	CALL	PUT		; WRITE THE FILE TO DISK
	CALL	SPMSG		; PERMIT MORE WRITES
	DB	"WANT ANOTHER COPY",0
	CALL	GETYN
	JZ	START2		; LOOP FOR MORE WRITES
DONE:	LDA	DRSAV		; RESTORE INITIAL DRIVE
	STA	DRIVE
	JMP	RBOOT

; READ A FILE FROM DISK INTO "BUFFR"
GET:	LXI	H,BUFFR		; GET BUFFER START
	SHLD	NEXT		;  ADDRESS FOR DMA
	LXI	D,TFCB		; SEE IF FILE IS ON DISK
	MVI	C,OPENF		; AND OPEN FOR READ
	CALL	BDOS
	CPI	BDERR		; IS IT THERE?
	JNZ	GET1		; YES, READ IT IN
	CALL	TWOCR		; NO, SHOW ERROR
	CALL	SPMSG
	DB	"CAN NOT FIND ",0
	CALL	SHOFN
ERREX:	CALL	TWOCR		; ERROR EXIT TO CP/M
	JMP	DONE
GET1:	XRA	A		; ZERO RECORD COUNTER
	STA	RECCT		; AND READ A FILE INTO BUFFR
GET2:	LHLD	NEXT		; SET BUFFER ADDRESS
	XCHG
	MVI	C,SDMAF
	CALL	BDOS
	LXI	D,TFCB		; READ ONE RECORD INTO
	MVI	C,READF		; BUFFER
	CALL	BDOS
	CPI	BDAOK		; READ OK?
	JZ	GET3		; YES, DO MORE
	CPI	BDER1		; MAYBE, END OF FILE?
	JZ	GETEX		; YES, NO PROBLEM
	CALL	REMSG		; NO, SHOW ERROR
	JMP	ERREX		; AND ALL DONE

GET3:	LDA	RECCT		; COUNT THE RECORD
	INR	A
	STA	RECCT
	LHLD	NEXT		; INCREMENT BUFFER ADDRESS
	LXI	D,128		; BY RECORD SIZE
	DAD	D
	SHLD	NEXT
	LDA	MEMAX		; ROOM LEFT IN RAM?
	DCR	A		; STOP BELOW CCP
	CMP	H		; COMPARE MSB
	JNZ	GET2		; CONTINUE IF NOT EQUAL
	CALL	TWOCR		; ELSE SHOW OUT OF MEMORY
	CALL	SPMSG
	DB	"OUT OF MEMORY",0
	JMP	ERREX		; AND GIVE UP

GETEX:	CALL	CCRLF		; NORMAL EXIT
	CALL	CPDMA		; RESTORE CP/M DMA
	RET

; WRITE A FILE FROM "BUFFR" TO DISK

PUT:	LXI	H,BUFFR		; SET UP BUFFER START
	SHLD	NEXT
	LDA	RECCT		; SAVE RECORD COUNT
	STA	CTSAV
	LDA	TFCB		; LOG-IN SELECTED DISK
	ORA	A		; IS IT LEGAL?
	JNZ	PUT1
	CALL	WROPN		; NO, SHOW UNABLE TO OPEN
	JMP	PUTEX		; AND TRY AGAIN
PUT1:	MVI	C,INITF		; ENABLE WRITE ON ANY DISK
	CALL	BDOS
	XRA	A		; INITIALIZE FCB
	STA	FCBCR		; CURRENT RECORD
	LXI	H,0
	SHLD	FCBEX		; EXTENT AND S1
	SHLD	FCBS2		; S2 AND RECORD COUNT
	LXI	D,TFCB		; SEE IF FILE EXISTS
	MVI	C,FINDF		; FIND FUNCTION
	CALL	BDOS
	CPI	BDERR		; IS IT ALREADY?
	JZ	PUT2
	CALL	CCRLF		; YES, OK TO ERASE?
	CALL	SPMSG
	DB	"OK TO ERASE ",0
	CALL	SHOFN
	CALL	GETYN
	JNZ	PUTEX		; IF NO, TRY AGAIN
	LXI	D,TFCB		; IF YES, ERASE IT
	MVI	C,DELEF		; DELETE FUNCTION
	CALL	BDOS
PUT2:	LXI	D,TFCB		; OPEN FILE FOR WRITE
	MVI	C,MAKEF		; MAKE A FILE FUNCTION
	CALL	BDOS
	CPI	BDERR		; GOT IT MADE?
	JNZ	PUT3
	CALL	WROPN		; NO, SHOW UNABLE
	JMP	PUTEX		; AND TRY AGAIN

PUT3:	LHLD	NEXT		; WRITE BUFFER TO DISK
	XCHG			; (FINALLY)
	MVI	C,SDMAF		; SET ADDRESS TO WRITE FROM
	CALL	BDOS
	LHLD	NEXT		; THEN INCREMENT BY 128
	LXI	D,128
	DAD	D
	SHLD	NEXT
	LXI	D,TFCB
	MVI	C,WRITF		; WRITE A RECORD FUNCTION
	CALL	BDOS
	CPI	BDAOK		; WRITE OK?
	JZ	PUT4
	CALL	WEMSG		; NO, WRITE ERROR MESSAGE
	JMP	PUTEX		; AND TRY AGAIN
PUT4:	LDA	RECCT		; COUNT THE RECORD
	DCR	A
	STA	RECCT		; IF NOT END OF RECORDS
	JNZ	PUT3		; THEN DO ANOTHER
	CALL	CPDMA		; ELSE RESTORE CP/M DMA
	LXI	D,TFCB
	MVI	C,CLOSF		; THEN CLOSE THE FILE
	CALL	BDOS
	LDA	CTSAV		; RESTORE RECORD COUNT
	STA	RECCT		; FOR NEXT WRITE
PUTEX:	CALL	CCRLF
	CALL	CPDMA		; RESTORE CP/M DMA
	RET			; AND ALL DONE

; DISPLAY FILENAME.TYPE FROM TRANSIENT FCB
SHOFN:	PUSH	B		; SAVE TEMP STORE
	PUSH	H		; AND INDEX
	LDA	FCBTY		; SAVE FIRST CHAR OF TYPE
	MOV	C,A		; IN TEMPORARY STORE
	XRA	A		; FORCE TWO TERMINATORS
	STA	FCBTY		; FOR FILE NAME
	STA	FCBEX		; AND FILE TYPE
	LXI	H,TFCB		; SHOW DISK DRIVE
	MOV	A,M
	ANI	0FH		; LIMIT TO 4 BITS
	ORI	40H		; CONVERT TO ASCII
	CALL	CO
	MVI	A,':'		; SHOW THE COLON
	CALL	CO
	INX	H		; AND SHOW THE FILENAME
	CALL	COMSG
	MOV	A,C
	LXI	H,FCBTY		; RESTORE TYPE
	MOV	M,A
	MVI	A,'.'		; SHOW SEPARATOR
	CALL	CO
	CALL	COMSG		; SHOW TYPE
	POP	H
	POP	B		; RESTORE AND
	RET			; RETURN

; DISPLAY READ ERROR MESSAGE
REMSG:	CALL	TWOCR
	CALL	SPMSG
	DB	"PERMANENT READ ERROR",CR,LF,0
	RET

; DISPLAY WRITE ERROR MESSAGE
WEMSG:	CALL	TWOCR
	CALL	SPMSG
	DB	"PERMANENT WRITE ERROR",CR,LF,0
	RET

; DISPLAY WRITE OPEN ERROR MESSAGE
WROPN:	CALL	TWOCR
	CALL	SPMSG
	DB	"CAN NOT OPEN FOR WRITE",CR,LF,0
	RET

; RESTORE CP/M DMA ADDRESS TO THE TRANSIENT BUFFER
CPDMA:	LXI	D,TBUFF
	MVI	C,SDMAF
	CALL	BDOS
	RET

; GET A VALID DRIVE SELECT DESIGNATOR
DRSEL:	CALL	CIMSG		; INPUT THE SELECTION
	LDA	INBUF+2		; USE FIRST CHARACTER ONLY
	ANI	01011111B	; CONVERT TO UPPER CASE
	SUI	'@'		; SET A=1, B=2, ETC.
	JM	DRERR		; CAN'T BE LESS THAN ZERO
	SUI	17		; OR GREATER THAN 16
	JP	DRERR
	ADI	17		; RESTORE LEGAL NUMBER
	RET			; AND RETURN WITH IT
DRERR:	XRA	A		; ELSE SET ZERO FLAG
	RET			; AND RETURN

; CONSOLE CHARACTER INTO REGISTER A MASKED TO 7 BITS
CI:	PUSH	B		; SAVE REGISTERS
	PUSH	D
	PUSH	H
	MVI	C,RCONF		; READ FUNCTION
	CALL	BDOS
	ANI	7FH		; MASK TO 7 BITS
	POP	H		; RESTORE REGISTERS
	POP	D
	POP	B
	RET

; CHARACTER IN REGISTER A OUTPUT TO CONSOLE
CO:	PUSH	B		; SAVE REGISTERS
	PUSH	D
	PUSH	H
	MVI	C,WCONF		; SELECT FUNCTION
	MOV	E,A		; CHARACTER TO E
	CALL	BDOS		; OUTPUT BY CP/M
	POP	H		; RESTORE REGISTERS
	POP	D
	POP	B
	RET

; CARRIAGE RETURN, LINE FEED TO CONSOLE
TWOCR:	CALL	CCRLF
CCRLF:	MVI	A,CR
	CALL	CO
	MVI	A,LF
	JMP	CO

; MESSAGE POINTED TO BY HL OUT TO CONSOLE
COMSG:	MOV	A,M		; GET A CHARACTER
	ORA	A		; ZERO IS THE TERMINATOR
	RZ			; ZERO IS THE TERMINATOR
	CALL	CO		; ELSE OUTPUT THE CHARACTER
	INX	H		; POINT TO THE NEXT ONE
	JMP	COMSG		; AND CONTINUE

; INPUT CONSOLE MESSAGE INTO BUFFER
CIMSG:	PUSH	B		; SAVE REGISTERS
	PUSH	D
	PUSH	H
	LXI	H,INBUF+1	; ZERO CHARACTER COUNTER
	MVI	M,0
	DCX	H		; SET MAXIMUM LINE LENGTH
	MVI	M,80
	XCHG			; INBUF POINTER TO DE REGISTER
	MVI	C,RBUFF		; SET UP READ BUFFER FUNCTION
	CALL	BDOS		; INPUT A LINE
	LXI	H,INBUF+1	; GET CHARACTER COUNTER
	MOV	E,M		; INTO LSB OF DE REGISTER PAIR
	MVI	D,0		; ZERO MSB
	DAD	D		; ADD LENGTH TO START
	INX	H		; PLUS ONE POINTS TO END
	MVI	M,0		; INSERT TERMINATOR AT END
	POP	H		; RESTORE ALL REGISTERS
	POP	D
	POP	B
	RET

; MESSAGE POINTED TO BY STACK OUT TO CONSOLE
SPMSG:	XTHL			; GET "RETURN ADDRESS" TO HL
	XRA	A		; CLEAR FLAGS AND ACCUMULATOR
	ADD	M		; GET ONE MESSAGE CHARACTER
	INX	H		; POINT TO NEXT
	XTHL			; RESTORE STACK FOR
	RZ			; RETURN IF DONE
	CALL	CO		; ELSE DISPLAY CHARACTER
	JMP	SPMSG		; AND DO ANOTHER

; GET YES OR NO FROM CONSOLE
GETYN:	CALL	SPMSG		; PROMPT FOR INPUT
	DB	" (Y/N)?: ",0
	CALL	CIMSG		; GET INPUT LINE
	CALL	CCRLF		; ECHO CARRIAGE RETURN
	LDA	INBUF+2		; FIRST CHARACTER ONLY
	ANI	01011111B	; CONVERT LOWER CASE TO UPPER
	CPI	'Y'		; RETURN WITH ZERO	= YES
	RZ
	CPI	'N'		; NON-ZERO = NO
	JNZ	GETYN		; ELSE TRY AGAIN
	CPI	0		; RESET ZERO FLAG
	RET			; AND ALL DONE

; RAM VARIABLES AND BUFFERS
INBUF:	DS	83		; LINE INPUT BUFFER
DRSAV:	DS	1		; CURRENT DRIVE AT ENTRY
RECCT:	DS	1		; TOTAL RECORDS READ/TO WRITE
CTSAV:	DS	1		; SAVE LOCATION FOR COUNT
NEXT:	DS	2		; NEXT DMA ADDRESS

; SET UP STACK SPACE
	DS	64		; 40H LOCATIONS
STAK:	DB	0		; TOP OF STACK

SINON:	DB	"MULTI-WRITE FILE COPY  12 SEPT 82",0

; FROM HERE THROUGH CCP IS BUFFER SPACE
BUFFR:

	END
