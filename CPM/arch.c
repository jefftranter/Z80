/*

  Simple file archiver. Combines multiple files into a single file to
  simplify uploads, etc. Runs on Linux, CP/M, and HDOS. A corresponding
  program can extract them.

*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <sys/stat.h>

/*
  File format:

  3 byte magic number ("JJT")
  # of files in archive (unsigned byte)
  directory: for each file:
    filename (12 chars, padded with nulls)
    length of file in bytes (4 byte unsigned long integer)
  data for each file:
    data for file 1 (as per file length)
    data for file 2 (as per file length)
    data for file 3 (as per file length)
    ...
  3 byte end of archive file marker ("END")

*/

/* Below was initially generated by ChatGPT. */
int validate_cpm_filename(const char *filename) {
    int len = strlen(filename);

    // Filename must not be longer than 11 characters + dot
    if (len > 12) {
        return 0;  // Invalid filename length
    }

    // Variables to track whether we have seen the period for extension
    int has_period = 0;
    int name_length = 0;
    int ext_length = 0;

    // Check each character of the filename
    for (int i = 0; i < len; i++) {
        char c = filename[i];

        // If we encounter a period, it's allowed only once
        if (c == '.') {
            if (has_period) {
                return 0;  // Invalid: more than one period
            }
            has_period = 1;
        }
        // Check if the character is a valid CP/M filename character
        else if (!isalnum(c) && c != '-' && c != '.' && c != '_') {
            return 0;  // Invalid character
        }

        // Count lengths of name and extension parts (but not ".")
        if (c != '.') {
            if (has_period) {
                ext_length++;
            } else {
                name_length++;
            }
        }
    }

    // Check if name and extension lengths are within the valid ranges
    if (name_length > 8 || ext_length > 3) {
        return 0;  // Invalid length for name or extension
    }

    return 1;  // Valid filename
}

int main(int argc, char **argv)
{
    struct stat statbuf;
    int rc;
    int numfiles;
    int i, j, n;
    FILE *afp;
    FILE *fp;
    char buffer[256];

    /* Check command line options */
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <archive file> <filename>...\n", argv[0]);
        return 1;
    }
    numfiles = argc - 2;

    /* Make sure that output file does not already exist, otherwise
       refuse to continue. We could use stat() for this, but it does not
       work on CP/M so we try to open it for read instead. */
    afp = fopen(argv[1], "rb");
    if (afp != NULL) {
        fclose(afp);
        fprintf(stderr, "Error: output file %s already exists. Remove it if this is correct.\n", argv[1]);
        return 1;
    }

    /* Validate filename for CP/M and HDOS. */
    if (!validate_cpm_filename(argv[1])) {
        fprintf(stderr, "Warning: filename %s is not valid for HDOS and CP/M.\n", argv[1]);
    }

    /* Open output file. */
    afp = fopen(argv[1], "wb");

    if (afp == NULL) {
        fprintf(stderr, "Error: fopen of %s failed\n", argv[1]);
        return 1;
    }

    /* Write out magic number. */
    fprintf(afp, "JJT");

    /* Write out number of files in archive (unsigned byte). */
    fprintf(afp, "%c", numfiles);

    /* Write file directory */
    for (i = 2; i < numfiles + 2; i++) {

        rc = stat(argv[i], &statbuf);

        if (rc != 0) {
            fprintf(stderr, "Error: stat of %s failed, rc = %d\n", argv[i], rc);
            return 1;
        }

        /* Validate filename for CP/M and HDOS. */
        if (!validate_cpm_filename(argv[i])) {
            fprintf(stderr, "Error: filename %s is not valid for HDOS and CP/M.\n", argv[i]);
            return 1;
        }

        /* Write filename, padded with zeroes to 12 characters. */
        for (j = 0; j < 12; j++) {
            fprintf(afp, "%c", (j < strlen(argv[i]) ? argv[i][j] : 0));
        }

        /* Write size as four byte integer. */
        fprintf(afp, "%c%c%c%c",
                (char)((statbuf.st_size >> 24) & 0xff),
                (char)((statbuf.st_size >> 16) & 0xff),
                (char)((statbuf.st_size >> 8) & 0xff),
                (char)((statbuf.st_size) & 0xff)
                );
    }

    /* Now write raw contents of each file. */
    for (i = 1; i < numfiles + 2; i++) {

        fp = fopen(argv[i], "rb");

        if (fp == NULL) {
            fprintf(stderr, "Error: open of %s failed\n", argv[i]);
            return 1;
        }

        fprintf(stderr, "Adding file %s\n", argv[i]);

        do {
            n = fread(buffer, 1, 256, fp);
            fwrite(buffer, 1, n, afp);
        } while (n > 0);

        fclose(fp);
    }

    /* Write end of archive file marker */
    fprintf(afp, "%s", "END");

    fclose (afp);

    return 0;
}
